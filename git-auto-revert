#!/usr/bin/env bash
# reverts all the commits matching the given criteria

# Conventional commit message tag expression examples
#     feat                  type=feat, scope=none or any, breaking=yes or no
#     feat(api)             type=feat, scope=api, breaking=yes or no
#     feat(api)!            type=feat, scope=api, breaking=yes
#     feat(api)!!           type=feat, scope=api, breaking=no
#     feat(*)               type=feat, scope=any, breaking=yes or no
#     feat(!*)              type=feat, scope=none, breaking=yes or no
#     !feat                 type=anything except feat, scope=none or any, breaking=yes or no
#     feat(!api)            type=feat, scope=anything except api, breaking=yes or no
#     feat(api|client)      type=feat scope=api or client, breaking=yes or no
#     feat(!api|client)     type=feat scope=anything except api or client, breaking=yes or no

__DIR__=$(dirname -- "${BASH_SOURCE[0]}")

. "$__DIR__/lib/core/error.bash"
. "$__DIR__/lib/core/log.bash"
. "$__DIR__/lib/git/core.bash"
. "$__DIR__/lib/git/log.bash"
. "$__DIR__/lib/git/revision.bash"
. "$__DIR__/lib/git/tag.bash"
. "$__DIR__/lib/util/get_options.bash"

check_prerequisites() {
  check_git_command
  check_git_repository
}

check_status() {
  if has_staged_changes || has_unstaged_changes; then
    error "your local changes would be overwritten by auto-revert." 0
    hint "commit your changes or stash them to proceed."
    fatal "auto-revert failed" $RET_GENERIC_ERROR
  fi
}

print_usage() {
  echo "usage: git auto-revert <tag> [<options>]
   or: git auto-revert --grep=<pattern> [<options>]

    -s, --single-commit   revert commits within a single commit
    -m, --message         commit message for single revert commit. ignored if not reverting in a single commit
    -n, --no-commit       don't automatically commit
    -e, --[no-]edit       edit the commit message
    --[no-]auto-skip-empty
                          automatically skip commits which have no change to be reverted
    --grep=<pattern>      limit the commits to be reverted to ones with a log message that match the specified pattern. required if <tag> is not specified
    --author=<pattern>    author to filter commits to revert. set to \"me\" to revert only the commits authored by the current user
    --committer=<pattern> committer to filter commits to revert. set to \"me\" to revert only the commits comitted by the current user
    --since=<date>, --after=<date>
                          limit commits to be reverted to the ones that are more recent than a specific date
    --until=<date>, --before=<date>       
                          limit commits to be reverted to the ones that are older than a specific date
    --since-commit=<commit>, --after-commit=<commit>
                          limit commits to be reverted to the ones that are more recent than the specified commit (excluding specified commit)
    --until-commit=<commit>, --before-commit=<commit>
                          limit commits to be reverted to the ones that are older than the specified commit (including specified commit)
    --since-tag=<tag>, --after-tag=<tag>
                          limit commits to be reverted to the ones that are more recent than the specified Git tag (excluding the commit specified tag points to)
    --until-tag=<tag>, --before-tag=<tag>
                          limit commits to be reverted to the ones that are older than the specified Git tag (including the commit specified tag points to)
    --conventional        consider commit message tag specified as <tag> as a conventional commit message tag pattern

Options related to limiting patterns (ignored if no pattern is specified with --grep=<pattern>)
    --all-match           limit the commits to be reverted to ones that match all given --grep, instead of ones that match at least one
    --invert-grep         limit the commits to be reverted to ones with a log message that do not match the pattern specified with --grep=<pattern>
    -i, --regexp-ignore-case 
                          match the regular expression limiting patterns without regard to letter case
    --basic-regexp        consider the limiting patterns to be basic regular expressions; this is the default
    -E, --extended-regexp consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions
    -F, --fixed-strings   consider the limiting patterns to be fixed strings (don't interpret pattern as a regular expression)
    -P, --perl-regex      consider the limiting patterns to be Perl-compatible regular expressions
"
}

validate_options() {
  if [ -n "$tag" ] && [ "${#grep[@]}" -gt 0 ]; then
    error "<tag> cannot be used with --grep" $RET_ILLEGAL_OPTION
  fi

  if [ -z "$tag" ] && [ "${#grep[@]}" -eq 0 ]; then
    error "either a <tag> or --grep must be specified" $RET_ILLEGAL_OPTION
  fi

  if [ -n "$since_commit" ] && [ -n "$since_tag" ]; then
    error "--since-commit or --after-commit cannot be used with --since-tag or --after-tag" $RET_ILLEGAL_OPTION
  fi

  if [ -n "$until_commit" ] && [ -n "$until_tag" ]; then
    error "--until-commit or --before-commit cannot be used with --until-tag or --before-tag" $RET_ILLEGAL_OPTION
  fi

  if [ -n "$single_commit" ] && [ -n "$tag_conventional" ] && [ -z "$single_commit_message" ]; then
    error "--message is required when reverting in a single commit and the tag is a conventional commit message pattern" $RET_ILLEGAL_OPTION
  fi

  if [ "$single_commit" == "true" ] && [ "$no_commit" == "true" ]; then
    error "--single-commit cannot be used with --no-commit" $RET_ILLEGAL_OPTION
  fi
}

parse_options() {
  grep=()
  auto_skip_empty=true

  if [[ ! "$1" == -* ]]; then
    OPTIND=2
    tag="$1"
  else
    OPTIND=1
  fi

  local long_opts="help,single-commit,message:,no-commit,edit,no-edit,auto-skip-empty,no-auto-skip-empty,grep:,author:,committer:"
  long_opts+=",since:,after:,until:,before:,since-commit:,after-commit:,until-commit:,before-commit:,since-tag:,after-tag:,until-tag:,before-tag:"
  long_opts+=",conventional,all-match,invert-grep,regexp-ignore-case,basic-regexp,extended-regexp,fixed-strings,perl-regexp"

  while get_options "hsm:neiEFP" "$long_opts" opt "$@"; do
    case "$opt" in
    h | help)
      print_usage
      exit 0
      ;;
    s | single-commit)
      single_commit=true
      ;;
    m | message)
      single_commit_message="$OPTARG"
      ;;
    n | no-commit)
      no_commit=true
      ;;
    e | edit)
      edit=true
      ;;
    auto-skip-empty)
      auto_skip_empty=true
      ;;
    no-auto-skip-empty)
      auto_skip_empty=false
      ;;
    no-edit)
      edit=false
      ;;
    grep)
      grep+=("$OPTARG")
      ;;
    all-match)
      all_match=true
      ;;
    invert-grep)
      invert_grep=true
      ;;
    i | regexp-ignore-case)
      regexp_ignore_case=true
      ;;
    basic-regexp)
      basic_regexp=true
      ;;
    E | extended-regexp)
      extended_regexp=true
      ;;
    F | fixed-strings)
      fixed_strings=true
      ;;
    P | perl-regexp)
      perl_regexp=true
      ;;
    author)
      author="$OPTARG"
      ;;
    committer)
      committer="$OPTARG"
      ;;
    since | after)
      since="$OPTARG"
      ;;
    until | before)
      until="$OPTARG"
      ;;
    since-commit | after-commit)
      since_commit="$OPTARG"
      ;;
    until-commit | before-commit)
      until_commit="$OPTARG"
      ;;
    since-tag | after-tag)
      since_tag="$OPTARG"
      ;;
    until-tag | before-tag)
      until_tag="$OPTARG"
      ;;
    conventional)
      tag_conventional=true
      ;;
    :)
      error_missing_opt_value "$OPTARG"
      ;;
    *)
      error_unknown_opt "$OPTARG"
      ;;
    esac
  done

  validate_options
}

find_commits() {
  if [[ -n "$since_commit" ]]; then
    check_revision "$since_commit" || error "unknown revision: $since_commit"
    local rev_start="$since_commit"
  elif [[ -n "$since_tag" ]]; then
    check_revision "$since_tag" || error "unknown revision: $since_tag"
    check_tag "$since_tag" || error "not a tag: $since_tag"
    local rev_start="$(resolve_revision "$since_tag")"
  fi

  if [[ -n "$until_commit" ]]; then
    check_revision "$until_commit" || error "unknown revision: $until_commit"
    local rev_end="$until_commit"
  elif [[ -n "$until_tag" ]]; then
    check_revision "$until_tag" || error "unknown revision: $until_tag"
    check_tag "$since_tag" || error "not a tag: $until_tag"
    local rev_end="$(resolve_revision "$until_tag")"
  fi

  if [[ -n "$rev_start" ]] || [[ -n "$rev_end" ]]; then
    if [[ -z "$rev_start" ]]; then
      local rev_start="$(find_initial_commit)"
    fi

    local revision_range="$rev_start..$rev_end"
  fi

  local find_commits_opts=()

  if [[ ${#grep[@]} -gt 0 ]]; then
    for grep_val in "${grep[@]}"; do
      find_commits_opts+=(--grep "$grep_val")
    done

    if [[ -n "$all_match" ]]; then
      find_commits_opts+=(--all-match)
    fi

    if [[ -n "$invert_grep" ]]; then
      find_commits_opts+=(--invert-grep)
    fi

    if [[ -n "$regexp_ignore_case" ]]; then
      find_commits_opts+=(--regexp-ignore-case)
    fi

    if [[ -n "$basic_regexp" ]]; then
      find_commits_opts+=(--basic-regexp)
    fi

    if [[ -n "$extended_regexp" ]]; then
      find_commits_opts+=(--extended-regexp)
    fi

    if [[ -n "$fixed_strings" ]]; then
      find_commits_opts+=(--fixed-strings)
    fi

    if [[ -n "$perl_regexp" ]]; then
      find_commits_opts+=(--perl-regexp)
    fi
  fi

  if [[ -n "$author" ]]; then
    find_commits_opts+=(--author "$author")
  fi

  if [[ -n "$committer" ]]; then
    find_commits_opts+=(--committer "$committer")
  fi

  if [[ -n "$since" ]]; then
    find_commits_opts+=(--since "$since")
  fi

  if [[ -n "$until" ]]; then
    find_commits_opts+=(--until "$until")
  fi

  if [[ -z "$tag" ]]; then
    commit_hashes=($(list_commits "$revision_range" "${find_commits_opts[@]}"))
  else
    commit_hashes=($(list_commits_by_tag "$tag" "$revision_range" "${find_commits_opts[@]}"))
  fi
}

build_commit_message() {
  local commit_message

  if [ -n "$single_commit_message" ]; then
    commit_message="$single_commit_message"
  else
    commit_message="Revert \"$tag\""
  fi

  commit_message+=$'\n\n'

  for commit in "${commit_hashes[@]}"; do
    if is_skipped "$commit"; then
      continue
    fi
    commit_message+="This reverts commit $commit."$'\n'
  done

  printf "$commit_message"
}

is_skippable() {
  local gitdir="$(get_git_dir)"
  has_sequencer && ! [ -f "$gitdir/REVERT_HEAD" ] && ! has_staged_changes && ! has_unstaged_changes
}

is_skipped() {
  local commit="$1"

  for skipped_commit in "${skipped_commit_hashes[@]}"; do
    if [ "$skipped_commit" == "$commit" ]; then
      true
      return
    fi
  done

  false
}

commit() {
  local message=$(build_commit_message)
  local commit_opts=()

  if [ "$edit" == "true" ]; then
    commit_opts+=(--edit)
  else
    commit_opts+=(--no-edit)
  fi

  git commit -m "$message" ${commit_opts[@]}
}

squash_commits() {
  local base_commit="$1"
  git reset $base_commit --soft
  commit
}

revert() {
  if [ -z "$commit_hashes" ]; then
    error "no matching commits found. nothing to do" $RET_GENERIC_ERROR
  fi

  local base_commit=$(resolve_revision HEAD)

  local revert_opts=()

  if [ "$no_commit" == "true" ]; then
    revert_opts+=(--no-commit)
  fi

  if [ "$edit" == "true" ] && [ "$single_commit" != "true" ]; then
    revert_opts+=(--edit)
  else
    revert_opts+=(--no-edit)
  fi

  git revert ${revert_opts[@]} ${commit_hashes[@]} >/dev/null

  local revert_result=$?
  skipped_commit_hashes=()

  if [ $revert_result -ne 0 ] && [ "$auto_skip_empty" == "true" ]; then
    while [ $revert_result -ne 0 ] && is_skippable; do
      local next_todo=$(get_next_todo)

      git revert --skip >/dev/null
      revert_result=$?

      local todo_parts
      IFS=' ' read -r -a todo_parts <<<"$next_todo"
      skipped_commit_hashes+=($(resolve_revision ${todo_parts[1]}))
    done
  fi

  local numreverted=$((${#commit_hashes[@]} - ${#skipped_commit_hashes[@]}))

  if [ $numreverted -eq 0 ]; then
    echo "All matched commits are skipped. Nothing to revert"
  elif [ $revert_result -eq 0 ]; then
    if [ "$single_commit" == "true" ]; then
      squash_commits "$base_commit"
    fi

    printf "Successfully reverted $numreverted commit(s)"
    if [ ${#skipped_commit_hashes[@]} -ne 0 ]; then
      printf " (skipped ${#skipped_commit_hashes[@]})"
    fi
    echo ""
  else
    error "unable to revert" 0
    if has_sequencer && (has_staged_changes || has_unstaged_changes); then
      hint "fix the conflicts and use \"git revert --continue\" to continue the revert operation manually"
      hint "or use \"git revert --abort\" to cancel the revert operation"
    fi
    fatal "auto-revert failed" $RET_GENERIC_ERROR
  fi
}

check_prerequisites
parse_options "$@"
check_status

find_commits
revert
