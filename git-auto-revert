#!/usr/bin/env bash
# reverts all the commits matching the given criteria

# Conventional commit message tag expression examples
#     feat                  type=feat, scope=none or any, breaking=yes or no
#     feat(api)             type=feat, scope=api, breaking=yes or no
#     feat(api)!            type=feat, scope=api, breaking=yes
#     feat(api)!!           type=feat, scope=api, breaking=no
#     feat(*)               type=feat, scope=any, breaking=yes or no
#     feat(!*)              type=feat, scope=none, breaking=yes or no
#     !feat                 type=anything except feat, scope=none or any, breaking=yes or no
#     feat(!api)            type=feat, scope=anything except api, breaking=yes or no
#     feat(api|client)      type=feat scope=api or client, breaking=yes or no
#     feat(!api|client)     type=feat scope=anything except api or client, breaking=yes or no

__DIR__=$(realpath -e -- "$(dirname -- "${BASH_SOURCE[0]}")")

. "$__DIR__/lib/core/error.bash"
. "$__DIR__/lib/git/core.bash"
. "$__DIR__/lib/git/log.bash"
. "$__DIR__/lib/git/revision.bash"
. "$__DIR__/lib/git/tag.bash"
. "$__DIR__/lib/util/get_options.bash"

check_prerequisites() {
  check_git_command
  check_git_repository
}

print_usage() {
  echo "usage: git auto-revert <tag> [<options>]
   or: git auto-revert --grep=<pattern> [<options>]

    -s, --single-commit   revert commits within a single commit
    -m, --message         commit message for single revert commit. ignored if not reverting in a single commit
    --grep=<pattern>      limit the commits to be reverted to ones with a log message that match the specified pattern. required if <tag> is not specified
    -b, --branch=<branch> branch to add the revert commits into. required if <tag> is not specified
    --author=<pattern>    author to filter commits to revert. set to \"me\" to revert only the commits authored by the current user
    --committer=<pattern> committer to filter commits to revert. set to \"me\" to revert only the commits comitted by the current user
    --since=<date>, --after=<date>
                          limit commits to be reverted to the ones that are more recent than a specific date
    --until=<date>, --before=<date>       
                          limit commits to be reverted to the ones that are older than a specific date
    --since-commit=<commit>, --after-commit=<commit>
                          limit commits to be reverted to the ones that are more recent than the specified commit (excluding specified commit)
    --until-commit=<commit>, --before-commit=<commit>
                          limit commits to be reverted to the ones that are older than the specified commit (including specified commit)
    --since-tag=<tag>, --after-tag=<tag>
                          limit commits to be reverted to the ones that are more recent than the specified Git tag (excluding the commit specified tag points to)
    --until-tag=<tag>, --before-tag=<tag>
                          limit commits to be reverted to the ones that are older than the specified Git tag (including the commit specified tag points to)
    --no-abort-on-failure don't abort the revert on failure
    --conventional        consider commit message tag specified as <tag> as a conventional commit message tag pattern

Options related to limiting patterns (ignored if no pattern is specified with --grep=<pattern>)
    --all-match           limit the commits to be reverted to ones that match all given --grep, instead of ones that match at least one
    --invert-grep         limit the commits to be reverted to ones with a log message that do not match the pattern specified with --grep=<pattern>
    -i, --regexp-ignore-case 
                          match the regular expression limiting patterns without regard to letter case
    --basic-regexp        consider the limiting patterns to be basic regular expressions; this is the default
    -E, --extended-regexp consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions
    -F, --fixed-strings   consider the limiting patterns to be fixed strings (don't interpret pattern as a regular expression)
    -P, --perl-regex      consider the limiting patterns to be Perl-compatible regular expressions
"
}

validate_options() {
  if [ -n "$tag" ] && [ "${#grep[@]}" -gt 0 ]; then
    error "<tag> cannot be used with --grep" $RET_ILLEGAL_OPTION
  fi

  if [ -z "$tag" ] && [ "${#grep[@]}" -eq 0 ]; then
    error "either a <tag> or --grep must be specified" $RET_ILLEGAL_OPTION
  fi

  if [ -z "$tag" ] && [ -z "$branch" ]; then
    error "--branch is required if <tag> is not specified" $RET_ILLEGAL_OPTION
  fi

  if [ -n "$since_commit" ] && [ -n "$since_tag" ]; then
    error "--since-commit or --after-commit cannot be used with --since-tag or --after-tag" $RET_ILLEGAL_OPTION
  fi

  if [ -n "$until_commit" ] && [ -n "$until_tag" ]; then
    error "--until-commit or --before-commit cannot be used with --until-tag or --before-tag" $RET_ILLEGAL_OPTION
  fi
}

parse_options() {
  grep=()

  if [[ ! "$1" == -* ]]; then
    OPTIND=2
    tag="$1"
  else
    OPTIND=1
  fi

  local long_opts="help,single-commit,message:,grep:,branch:,author:,committer:,since:,after:,until:,before:,since-commit:"
  long_opts+=",after-commit:,until-commit:,before-commit:,since-tag:,after-tag:,until-tag:,before-tag:"
  long_opts+=",no-abort-on-failure,conventional,all-match,invert-grep,regexp-ignore-case,basic-regexp,extended-regexp,fixed-strings,perl-regexp"

  while get_options "hsm:b:iEFP" "$long_opts" opt "$@"; do
    case "$opt" in
    h | help)
      print_usage
      exit 0
      ;;
    s | single-commit)
      single_commit=true
      ;;
    m | message)
      single_commit_message="$OPTARG"
      ;;
    grep)
      grep+=("$OPTARG")
      ;;
    all-match)
      all_match=true
      ;;
    invert-grep)
      invert_grep=true
      ;;
    i | regexp-ignore-case)
      regexp_ignore_case=true
      ;;
    basic-regexp)
      basic_regexp=true
      ;;
    E | extended-regexp)
      extended_regexp=true
      ;;
    b | branch)
      branch="$OPTARG"
      ;;
    F | fixed-strings)
      fixed_strings=true
      ;;
    P | perl-regexp)
      perl_regexp=true
      ;;
    author)
      author="$OPTARG"
      ;;
    committer)
      committer="$OPTARG"
      ;;
    since | after)
      since="$OPTARG"
      ;;
    until | before)
      until="$OPTARG"
      ;;
    since-commit | after-commit)
      since_commit="$OPTARG"
      ;;
    until-commit | before-commit)
      until_commit="$OPTARG"
      ;;
    since-tag | after-tag)
      since_tag="$OPTARG"
      ;;
    until-tag | before-tag)
      until_tag="$OPTARG"
      ;;
    no-abort-on-failure)
      no_abort=true
      ;;
    conventional)
      tag_conventional=true
      ;;
    :)
      error_missing_opt_value "$OPTARG"
      ;;
    *)
      error_unknown_opt "$OPTARG"
      ;;
    esac
  done

  validate_options
}

find_commits() {
  if [[ -n "$since_commit" ]]; then
    check_revision "$since_commit" || error "unknown revision: $since_commit"
    local rev_start="$since_commit"
  elif [[ -n "$since_tag" ]]; then
    check_revision "$since_tag" || error "unknown revision: $since_tag"
    check_tag "$since_tag" || error "not a tag: $since_tag"
    local rev_start="$(resolve_revision "$since_tag")"
  fi

  if [[ -n "$until_commit" ]]; then
    check_revision "$until_commit" || error "unknown revision: $until_commit"
    local rev_end="$until_commit"
  elif [[ -n "$until_tag" ]]; then
    check_revision "$until_tag" || error "unknown revision: $until_tag"
    check_tag "$since_tag" || error "not a tag: $until_tag"
    local rev_end="$(resolve_revision "$until_tag")"
  fi

  if [[ -n "$rev_start" ]] || [[ -n "$rev_end" ]]; then
    if [[ -z "$rev_start" ]]; then
      local rev_start="$(find_initial_commit)"
    fi

    local revision_range="$rev_start..$rev_end"
  fi

  local find_commits_opts=()

  if [[ ${#grep[@]} -gt 0 ]]; then
    for grep_val in "${grep[@]}"; do
      find_commits_opts+=(--grep "$grep_val")
    done

    if [[ -n "$all_match" ]]; then
      find_commits_opts+=(--all-match)
    fi

    if [[ -n "$invert_grep" ]]; then
      find_commits_opts+=(--invert-grep)
    fi

    if [[ -n "$regexp_ignore_case" ]]; then
      find_commits_opts+=(--regexp-ignore-case)
    fi

    if [[ -n "$basic_regexp" ]]; then
      find_commits_opts+=(--basic-regexp)
    fi

    if [[ -n "$extended_regexp" ]]; then
      find_commits_opts+=(--extended-regexp)
    fi

    if [[ -n "$fixed_strings" ]]; then
      find_commits_opts+=(--fixed-strings)
    fi

    if [[ -n "$perl_regexp" ]]; then
      find_commits_opts+=(--perl-regexp)
    fi
  fi

  if [[ -n "$author" ]]; then
    find_commits_opts+=(--author "$author")
  fi

  if [[ -n "$committer" ]]; then
    find_commits_opts+=(--committer "$committer")
  fi

  if [[ -n "$since" ]]; then
    find_commits_opts+=(--since "$since")
  fi

  if [[ -n "$until" ]]; then
    find_commits_opts+=(--until "$until")
  fi

  if [[ -z "$tag" ]]; then
    commit_hashes=$(list_commits "$revision_range" "${find_commits_opts[@]}")
  else
    commit_hashes=$(list_commits_by_tag "$tag" "$revision_range" "${find_commits_opts[@]}")
  fi
}

check_prerequisites
parse_options "$@"

find_commits
